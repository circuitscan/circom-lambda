AWSTemplateFormatVersion: '2010-09-09'
Description: >
  AWS CloudFormation Template to create a Lambda function that can start, stop, and get status of other CloudFormation stacks.

Parameters:
  StackName:
    Description: The name of the CloudFormation stack to be managed by the Lambda function.
    Type: String
  TemplateURL:
    Description: S3 URL of template to instantiate
    Type: String
    Default: https://s3.amazonaws.com/circuitscan-blobs.clonk.me/ec2-service.yaml
  KeyName:
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instance
    Type: AWS::EC2::KeyPair::KeyName
    ConstraintDescription: Must be the name of an existing EC2 KeyPair.
  EnvVars:
    Description: String of environment variables separated by spaces (e.g., "KEY1=value1 KEY2=value2")
    Type: String
    Default: ""
  AdminEmail:
    Description: Email to receive start/stop notifications (must be verified as sender in SES)
    Type: String
    Default: "ben@latenightsketches.com"
  CloudflareApiKey:
    Description: Cloudflare API Key
    Type: String
    NoEcho: true
  CloudflareZoneId:
    Description: Cloudflare Zone ID
    Type: String

Resources:
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service: 'lambda.amazonaws.com'
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: 'LambdaPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action:
                  - 'cloudformation:CreateStack'
                  - 'cloudformation:DeleteStack'
                  - 'cloudformation:DescribeStacks'
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                  - 'ses:SendEmail'
                  - 'ses:SendRawEmail'
                  - 'ec2:*'
                  - 'iam:*'
                Resource: '*'

  StartStopLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: 'StartStopCloudFormationStack'
      Handler: 'index.handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: 'nodejs20.x'
      Timeout: 60
      Environment:
        Variables:
          STACK_NAME: !Ref StackName
          TEMPLATE_URL: !Ref TemplateURL
          KEY_NAME: !Ref KeyName
          ENV_VARS: !Ref EnvVars
          ADMIN_EMAIL: !Ref AdminEmail
          CLOUDFLARE_API_KEY: !Ref CloudflareApiKey
          CLOUDFLARE_ZONE_ID: !Ref CloudflareZoneId
      Code:
        ZipFile: |
          const { CloudFormationClient, CreateStackCommand, DeleteStackCommand, DescribeStacksCommand } = require("@aws-sdk/client-cloudformation");
          const { SESClient, SendEmailCommand } = require("@aws-sdk/client-ses");

          const client = new CloudFormationClient({ region: process.env.AWS_REGION });
          const sesClient = new SESClient({ region: process.env.AWS_REGION });

          async function sendEmail(action, params, result) {
            const emailParams = {
              Source: process.env.ADMIN_EMAIL, // Replace with your verified SES email
              Destination: {
                ToAddresses: [process.env.ADMIN_EMAIL], // Replace with the recipient's email
              },
              Message: {
                Subject: {
                  Data: `CloudFormation Stack ${action}`,
                },
                Body: {
                  Text: {
                    Data: `Action: ${action}\nParams: ${JSON.stringify(params)}\nResult: ${JSON.stringify(result)}`,
                  },
                },
              },
            };

            try {
              await sesClient.send(new SendEmailCommand(emailParams));
            } catch (error) {
              console.error("Error sending email", error);
            }
          }

          exports.handler = async (event) => {
            console.log(event);
            const body = JSON.parse(event.body);
            const action = body.action;
            const params = body.params;

            if (action === 'start') {
              const stackName = process.env.STACK_NAME + generateRandomString(40);
              params.stackName = stackName;  // For the email
              const templateURL = process.env.TEMPLATE_URL;
              const cfParams = [
                {
                  ParameterKey: 'InstanceType',
                  ParameterValue: params.instanceType,
                },
                {
                  ParameterKey: 'KeyName',
                  ParameterValue: process.env.KEY_NAME,
                },
                {
                  ParameterKey: 'EnvVars',
                  ParameterValue: process.env.ENV_VARS,
                },
                {
                  ParameterKey: 'CloudflareApiKey',
                  ParameterValue: process.env.CLOUDFLARE_API_KEY,
                },
                {
                  ParameterKey: 'CloudflareZoneId',
                  ParameterValue: process.env.CLOUDFLARE_ZONE_ID,
                },
                {
                  ParameterKey: 'DnsRecordName',
                  ParameterValue: stackName,
                },
              ];

              const createParams = {
                StackName: stackName,
                TemplateURL: templateURL,
                Parameters: cfParams,
                Capabilities: ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
              };

              try {
                const createStackCommand = new CreateStackCommand(createParams);
                const createStackResponse = await client.send(createStackCommand);
                await sendEmail(action, params, { stackId: createStackResponse.StackId });
                return { stackId: createStackResponse.StackId };
              } catch (error) {
                await sendEmail(action, params, { error: error.message });
                return { error: error.message };
              }

            } else if (action === 'stop') {
              const stackId = params.stackId;

              const deleteParams = {
                StackName: stackId,
              };

              try {
                const deleteStackCommand = new DeleteStackCommand(deleteParams);
                await client.send(deleteStackCommand);
                await sendEmail(action, params, { message: 'Stack deletion initiated' });
                return { message: 'Stack deletion initiated' };
              } catch (error) {
                await sendEmail(action, params, { error: error.message });
                return { error: error.message };
              }

            } else if (action === 'status') {
              const stackId = params.stackId;

              const describeParams = {
                StackName: stackId,
              };

              try {
                const describeStacksCommand = new DescribeStacksCommand(describeParams);
                const describeStacksResponse = await client.send(describeStacksCommand);
                const stack = describeStacksResponse.Stacks[0];
                return {
                  status: stack.StackStatus,
                  outputs: stack.Outputs
                };
              } catch (error) {
                return { error: error.message };
              }

            } else {
              return { error: 'Invalid action specified' };
            }
          };

          function generateRandomString(length) {
              const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
              let result = '';
              for (let i = 0; i < length; i++) {
                  const randomIndex = Math.floor(Math.random() * characters.length);
                  result += characters[randomIndex];
              }
              return result;
          }

  LambdaFunctionUrl:
    Type: 'AWS::Lambda::Url'
    Properties:
      AuthType: 'NONE'
      TargetFunctionArn: !GetAtt StartStopLambdaFunction.Arn

  LambdaUrlInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunctionUrl'
      FunctionName: !Ref StartStopLambdaFunction
      Principal: '*'
      FunctionUrlAuthType: 'NONE'

Outputs:
  LambdaFunctionUrl:
    Description: 'URL of the Lambda Function'
    Value: !GetAtt LambdaFunctionUrl.FunctionUrl

